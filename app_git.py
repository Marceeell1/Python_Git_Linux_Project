# -*- coding: utf-8 -*-
"""app_git.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1wJCdies4bjN8dBTsgIXRMDHflJaBZiGu
"""

!pip install streamlit

import streamlit as st
import pandas as pd
import requests
import time
import matplotlib.pyplot as plt
import numpy as np
import seaborn as sns

# --- Page Configuration ---
st.set_page_config(page_title="Financial Dashboard", layout="wide")
st.title("ðŸ“Š Multi-Asset Quantitative Dashboard")

API_KEY = "CW1LL675242TSYOU"
URL = "https://www.alphavantage.co/query"

@st.cache_data
def get_data(symbol, is_crypto=False):
    """Fetch data from Alpha Vantage API."""
    params = {
        "function": "DIGITAL_CURRENCY_DAILY" if is_crypto else "TIME_SERIES_DAILY",
        "symbol": symbol,
        "apikey": API_KEY
    }
    if is_crypto: params["market"] = "USD"

    try:
        r = requests.get(URL, params=params).json()
        key = "Time Series (Digital Currency Daily)" if is_crypto else "Time Series (Daily)"
        if key in r:
            df = pd.DataFrame(r[key]).T
            col = "4b. close (USD)" if "4b. close (USD)" in df.columns else "4. close"
            df = df[[col]].rename(columns={col: "close"}).astype(float)
            df.index = pd.to_datetime(df.index)
            return df.sort_index()
    except:
        return None
    return None

# --- Data Loading ---
with st.spinner("Fetching market data..."):
    dfBTC = get_data("BTC", is_crypto=True)
    dfGLD = get_data("GLD")
    dfURTH = get_data("URTH")

if dfBTC is not None and dfGLD is not None and dfURTH is not None:
    # --- Data Processing ---
    data = pd.DataFrame({
        "Bitcoin": dfBTC["close"],
        "Gold": dfGLD["close"],
        "MSCI World": dfURTH["close"]
    }).dropna()

    returns = data.pct_change().dropna()

    # --- Portfolio Construction ---
    weights = [0.33, 0.33, 0.34]
    returns['Portfolio'] = returns.dot(weights)
    initial_cap = 10000
    values = (1 + returns).cumprod() * initial_cap

    # --- Metrics Calculation ---
    vol = returns['Portfolio'].std() * np.sqrt(252)
    sharpe = (returns['Portfolio'].mean() / returns['Portfolio'].std()) * np.sqrt(252)
    cum_max = values['Portfolio'].cummax()
    drawdown = (values['Portfolio'] - cum_max) / cum_max
    max_dd = drawdown.min()

    # --- Dashboard UI ---
    col1, col2, col3 = st.columns(3)
    col1.metric("Annualized Volatility", f"{vol:.2%}")
    col2.metric("Sharpe Ratio", f"{sharpe:.2f}")
    col3.metric("Max Drawdown", f"{max_dd:.2%}")

    st.subheader("Cumulative Performance ($10,000 Base)")
    st.line_chart(values[['Portfolio', 'Bitcoin', 'MSCI World']])

    st.subheader("Asset Correlations & Risk")
    c1, c2 = st.columns(2)

    with c1:
        fig_corr, ax_corr = plt.subplots()
        sns.heatmap(returns[['Bitcoin', 'Gold', 'MSCI World']].corr(), annot=True, cmap='coolwarm', ax=ax_corr)
        st.pyplot(fig_corr)

    with c2:
        # Diversification Benefit
        indiv_vols = returns[['Bitcoin', 'Gold', 'MSCI World']].std() * np.sqrt(252)
        theo_risk = sum(indiv_vols * weights)
        diff = (1 - (vol / theo_risk)) * 100
        st.write(f"**Individual Risk Avg:** {theo_risk:.2%}")
        st.write(f"**Actual Portfolio Risk:** {vol:.2%}")
        st.success(f"Diversification Benefit: {diff:.2f}% risk reduction")

else:
    st.error("API Limit reached or Connection Error. Please wait a minute and refresh.")